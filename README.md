# Min-Max-Median Priority Queue 구현 설명

---
## 0. 실행

### 개별 실행
```
gcc pq.c -o pq && ./pq
```

### 자동 채점 실행
```
chmod +x run_autograde.sh && ./run_autograde.sh
```

### 결과
```
make: Nothing to be done for `all'.
Test 1: PASS
Test 2: PASS
Test 3: PASS
Test 4: PASS
Total Score: 8 / 8
true
```

---

## 1. 개요
이 코드는 Min-Max-Median Priority Queue를 구현한 것으로, 두 개의 힙(최대 힙과 최소 힙)을 사용하여 중앙값을 효율적으로 관리합니다.

---

## 2. 주요 특징
- 두 개의 힙 사용: 최대 힙(maxHeap)과 최소 힙(minHeap)
- 최대 힙: 중앙값 이하의 값들을 저장 (루트가 중앙값)
- 최소 힙: 중앙값 초과의 값들을 저장
- 모든 연산은 매크로와 핵심 함수들을 사용하여 구현
- 힙의 균형을 유지하여 최대 힙과 최소 힙의 크기 차이가 최대 1이 되도록 함

---

## 3. 핵심 연산 및 동작 원리

### 3.1 삽입 (insert)
- **작동 원리**: 
  - 새로운 요소가 현재 중앙값(최대 힙의 루트) 이하면 최대 힙에 삽입
  - 새로운 요소가 현재 중앙값보다 크면 최소 힙에 삽입
  - 삽입 후 두 힙의 크기 차이가 1을 초과하면 균형을 맞추기 위해 요소 이동
- **균형 조정 과정**:
  - 최대 힙이 최소 힙보다 2개 이상 크면, 최대 힙의 루트(최대값)를 최소 힙으로 이동
  - 최소 힙이 최대 힙보다 크면, 최소 힙의 루트(최소값)를 최대 힙으로 이동
  - 이동 후 힙 속성을 유지하기 위해 heapify 연산 수행

### 3.2 삭제 연산
#### delete_min()
- **작동 원리**: 
  - 두 힙이 모두 비어있으면 -1 반환
  - 최소 힙이 비어있거나 최대 힙의 최소값이 최소 힙의 최소값(루트)보다 작으면 최대 힙에서 최소값 찾아 삭제
  - 그렇지 않으면 최소 힙의 루트(최소값) 삭제
  - 삭제 후 힙 균형이 깨지면 재조정
- **구현 세부사항**:
  - 최대 힙에서 최소값은 선형 탐색으로 찾음
  - 삭제 후 힙의 마지막 요소를 삭제된 위치로 이동하고 heapify 수행

#### delete_max()
- **작동 원리**:
  - 두 힙이 모두 비어있으면 -1 반환
  - 최대 힙이 비어있거나 최소 힙의 최대값이 최대 힙의 최대값(루트)보다 크면 최소 힙에서 최대값 찾아 삭제
  - 그렇지 않으면 최대 힙의 루트(최대값) 삭제
  - 삭제 후 힙 균형이 깨지면 재조정
- **구현 세부사항**:
  - 최소 힙에서 최대값은 선형 탐색으로 찾음
  - 삭제 후 힙의 마지막 요소를 삭제된 위치로 이동하고 heapify 수행

#### delete_median()
- **작동 원리**:
  - 두 힙이 모두 비어있으면 -1 반환
  - 중앙값은 항상 최대 힙의 루트에 있으므로, 최대 힙의 루트 삭제
  - 삭제 후 힙 균형을 맞추기 위해 필요시 최소 힙에서 요소 이동
- **구현 세부사항**:
  - 최대 힙의 루트를 삭제하고 마지막 요소를 루트 위치로 이동
  - heapify_down을 통해 힙 속성 유지

### 3.3 찾기 연산
#### find_min()
- **작동 원리**:
  - 두 힙이 모두 비어있으면 -1 반환
  - 최소 힙이 비어있으면 최대 힙에서 선형 탐색으로 최소값 찾아 반환
  - 최대 힙이 비어있으면 최소 힙의 루트(최소값) 반환
  - 두 힙 모두 요소가 있으면 각 힙의 최소값 중 작은 값 반환
- **구현 세부사항**:
  - 최대 힙에서 최소값은 O(n) 시간 복잡도로 선형 탐색

#### find_max()
- **작동 원리**:
  - 두 힙이 모두 비어있으면 -1 반환
  - 최대 힙이 비어있으면 최소 힙에서 선형 탐색으로 최대값 찾아 반환
  - 최소 힙이 비어있으면 최대 힙의 루트(최대값) 반환
  - 두 힙 모두 요소가 있으면 각 힙의 최대값 중 큰 값 반환
- **구현 세부사항**:
  - 최소 힙에서 최대값은 O(n) 시간 복잡도로 선형 탐색

#### find_median()
- **작동 원리**:
  - 두 힙이 모두 비어있으면 -1 반환
  - 중앙값은 항상 최대 힙의 루트에 있음
  - 최대 힙이 비어있으면 최소 힙의 루트가 중앙값
- **구현 세부사항**:
  - O(1) 시간 복잡도로 중앙값 즉시 반환

---

## 4. 시간 복잡도
- **삽입**: O(log n) - 힙에 삽입 및 힙 속성 유지
- **삭제**: 
  - delete_median(): O(log n) - 항상 최대 힙의 루트 삭제
  - delete_min(), delete_max(): O(n) 최악의 경우 (최소/최대값을 찾는 선형 탐색 때문)
- **찾기**: 
  - find_median(): O(1) - 항상 최대 힙의 루트 반환
  - find_min(), find_max(): O(n) 최악의 경우 (최소/최대값을 찾는 선형 탐색 때문)

---

## 5. 구현 세부사항
- 힙 인덱스는 1부터 시작 (인덱스 0은 사용하지 않음)
- 힙의 크기를 추적하는 maxSize와 minSize 변수 사용
- 힙 속성 유지를 위한 heapify 함수들:
  - max_heapify_up: 삽입 후 최대 힙 속성 유지 (상향식)
  - max_heapify_down: 삭제 후 최대 힙 속성 유지 (하향식)
  - min_heapify_up: 삽입 후 최소 힙 속성 유지 (상향식)
  - min_heapify_down: 삭제 후 최소 힙 속성 유지 (하향식)
- 파일 입출력을 통한 명령어 처리 (I: 삽입, D: 삭제, F: 찾기)

---

## 6. 코드 구조
```c
// 전역 변수
int maxHeap[MAX_SIZE];  // 중앙값 이하 (루트는 최대값)
int minHeap[MAX_SIZE];  // 중앙값 초과 (루트는 최소값)
int maxSize = 0;
int minSize = 0;

// 핵심 함수들
void insert(int element);
int delete_min();
int delete_max();
int delete_median();
int find_min();
int find_max();
int find_median();

// 힙 유지 함수들
void max_heapify_up(int *heap, int index);
void max_heapify_down(int *heap, int size, int index);
void min_heapify_up(int *heap, int index);
void min_heapify_down(int *heap, int size, int index);
```

---

## 7. 주의사항 및 핵심 아이디어
- **데이터 분할**: 중앙값을 기준으로 작은 값들은 최대 힙에, 큰 값들은 최소 힙에 저장
- **중앙값 위치**: 항상 최대 힙의 루트에 위치 (최대 힙이 비어있으면 최소 힙의 루트)
- **힙 균형**: 두 힙의 크기 차이가 최대 1이 되도록 유지, 이를 통해 중앙값 속성 보장
- **특수 케이스 처리**: 힙이 비어있는 경우에 대한 예외 처리 구현
- **효율성 개선 가능성**: 
  - 최소/최대값 찾기에서 선형 탐색 대신 더 효율적인 방법 고려 가능
  - 각 요소에 인덱스 정보를 추가하여 검색 속도 향상 가능

---

## 8. 확장 가능성
- 동적 메모리 할당을 통한 크기 제한 해제
- 다양한 데이터 타입 지원 (제네릭 프로그래밍)
- 멀티스레딩 환경에서의 동기화 처리
- 최소/최대값 찾기 연산 최적화 (인덱싱/추가 자료구조 사용)
